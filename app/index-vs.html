<!doctype html>
    <head>
        <meta charset="utf-8">
        <title>touchanimation</title>
        <meta name="viewport" content="width=device-width">
        <!-- build:css(.tmp) styles/main.css -->
        <link rel="stylesheet" href="styles/main.css">
        <!-- endbuild -->
    </head>
    <body style="height: 400px">
    <div class="scroll-viewport" style="height: 200px; margin-top: 20px; border: 1px solid black; position: relative; overflow: hidden">
        <div class="scroll-indicator" style="position:absolute;right:0;top:0;z-index:1;width:4px;height:40px;background-color:red"></div>
        <div class="scroll-header" style="background-color:grey;height:40px;position:absolute;top:-40px;width:100%">
            <div style="text-align: center" class="pull-to-refresh">Pull to refresh</div>
        </div>
        <div class="scroll-footer" style="background-color:grey;height:40px;position:absolute;top:100%;width:100%;z-index:1">
            Bottom...
        </div>
        <div class="scroll-content">
            <div class="block0" style="border: 1px solid yellow;">Block0</div>
            <div class="block1" style="border: 1px solid blue;">Block1</div>
        </div>
    </div>
        <!--
        <p>
        Performance comparison: Native slider
        <input type="range" min="0" max="100" style="width:200px">
        </p>
        -->

        <!-- build:js scripts/vendor.js -->
        <!-- bower:js -->
        <script src="scripts/web-animations.js"></script>
        <!-- endbower -->
        <!-- endbuild -->

    <!-- build:js scripts/touch-animation.js -->
    <script src="scripts/utils.js"></script>
    <script src="scripts/gesture.js"></script>
    <script src="scripts/scroll-animation.js"></script>
    <!-- endbuild -->

    <script>
        var     rowCount = 14,
                rowsPerPage = 6;


        var scrollViewport = document.querySelector('.scroll-viewport'),
                scrollContent = scrollViewport.querySelector('.scroll-content'),
                scrollHeader = scrollViewport.querySelector('.scroll-header'),
                scrollFooter = scrollViewport.querySelector('.scroll-footer'),
                pullToRefresh = scrollHeader.querySelector('.pull-to-refresh'),
                indicator = scrollViewport.querySelector('.scroll-indicator'),
                block0 = scrollViewport.querySelector('.block0'),
                block1 = scrollViewport.querySelector('.block1');

        fillBlock(block0, 0);
        fillBlock(block1, 1);

        var     rowHeight = utils.getHeight(block0) / rowsPerPage,
                blockHeight = rowHeight * rowsPerPage,
                viewPortHeight = utils.getHeight(scrollViewport),
                headerHeight = utils.getHeight(scrollHeader),
                footerHeight = utils.getHeight(scrollFooter),
                pullToRefreshWidth = utils.getWidth(scrollHeader),
                indicatorHeight = utils.getHeight(indicator);

        var headerFooterSlowDownFactor = 5,
            headerDuration = headerHeight / (rowHeight * rowCount) * headerFooterSlowDownFactor,
            footerDuration = footerHeight / (rowHeight * rowCount) * headerFooterSlowDownFactor;

        new ScrollAnimation({
            animation: new ParGroup([new SeqGroup([headerAnimation(), contentAnimation(), footerAnimation()]), indicatorAnimation()]),
            // based on contentAnimation, which has a duration of 1.
            pixelToTimeRatio: ((rowCount*rowHeight) - viewPortHeight) / 1,
            gesture: new gesture.SlideYGesture(document.body, -1),
            headerDuration: headerDuration,
            footerDuration: footerDuration
        });

        function indicatorAnimation() {
            var start = new Animation(indicator, [
                {offset: 0, transform: 'translateZ(0) translateY(-'+(indicatorHeight*0.9)+'px)'},
                {offset: 1, transform: 'translateZ(0) translateY(0)'}
            ], headerDuration);
            var middle = new Animation(indicator, [
                {offset: 0, transform: 'translateZ(0) translateY(0px)'},
                {offset: 1, transform: 'translateZ(0) translateY('+(viewPortHeight-indicatorHeight)+'px)'}
            ], 1);
            var end = new Animation(indicator, [
                {offset: 0, transform: 'translateZ(0) translateY('+(viewPortHeight-indicatorHeight)+'px)'},
                {offset: 1, transform: 'translateZ(0) translateY('+(viewPortHeight-indicatorHeight + indicatorHeight*0.9)+'px)'}
            ], footerDuration);
            return new SeqGroup([start, middle, end]);
        }

        function headerAnimation() {
            var headerAnimation = new Animation(scrollHeader, [
                {offset: 0, transform: 'translateZ(0) translateY('+headerHeight+'px)'},
                {offset: 1, transform: 'translateZ(0) translateY(0px)'}
            ], headerDuration);
            var contentAnimation = new Animation(scrollContent, [
                {offset: 0, transform: 'translateZ(0) translateY('+headerHeight+'px)'},
                {offset: 1, transform: 'translateZ(0) translateY(0px)'}
            ], headerDuration);
            var pullToRefreshAnimation = new Animation(pullToRefresh, [
                {offset: 0, transform: 'translateZ(0) rotate(0p)'},
                {offset: 1, transform: 'translateZ(0) rotate(360deg)'}
            ], headerDuration);
            return new ParGroup([headerAnimation, contentAnimation, pullToRefreshAnimation]);
        }

        function contentAnimation() {
            var blockAnimationHeight = 3*blockHeight,
                blockCount = rowCount / rowsPerPage;
            // Details about this calculation:
            // * blockCount / 2: As we have two block
            // * -0.5: We already show one page when we start -> half of one animation is already done
            // * ((blockHeight - viewPortHeight) / blockAnimationHeight): Adjust for difference between blockHeight and viewportHeight
            var blockIterations = (blockCount / 2) - 0.5 + ((blockHeight - viewPortHeight) / blockAnimationHeight);
            var block0Anim = new Animation(block0, [
                { offset: 0, transform: 'translateZ(0) translateY('+blockHeight+'px)' },
                { offset: 1, transform: 'translateZ(0) translateY(-'+blockHeight +'px)' }
            ], {
                iterationStart: 0.5,
                duration: 1 / blockIterations,
                iterations: blockIterations
            });
            var block1Anim = new Animation(block1, [
                { offset: 0, transform: 'translateZ(0) translateY(0px)' },
                { offset: 1, transform: 'translateZ(0) translateY(-'+(2*blockHeight) +'px)' }
            ], {
                duration: 1/blockIterations,
                iterations: blockIterations
            });
            // TODO: Bugs with the events (11/10/2013):
            // - no events while scrubbing backwards
            // - no events during running velocity animation. This might be due to the fact that
            //   we reparent the animation temporarily during animation.
            var block0Events = new SeqGroup([], {
                duration: 1/blockIterations,
                iterations: blockIterations,
                iterationStart: 0.5,
                // TODO: This seems to be a bug, we should not need this delay here!
                delay: headerDuration
            });
            var block1Events = new SeqGroup([], {
                duration: 1/blockIterations,
                iterations: blockIterations,
                // TODO: This seems to be a bug, we should not need this delay here!
                delay: headerDuration
            });
            block0Events.oniteration = function(e) {
                fillBlock(block0, e.iterationIndex * 2);
                // console.log('iterate0', block0Events.currentIteration, e);
            };
            block1Events.oniteration = function(e) {
                fillBlock(block1, e.iterationIndex * 2 + 1);
                console.log('iterate1');
            };

            return new ParGroup([block0Anim, block1Anim, block0Events, block1Events], {
                duration: 1
            });
        }

        function footerAnimation() {
            var footerAnimation = new Animation(scrollFooter, [
                {offset: 0, transform: 'translateZ(0) translateY(0px)'},
                {offset: 1, transform: 'translateZ(0) translateY(-'+footerHeight+'px)'}
            ], {
                duration: footerDuration
            });
            var contentAnimation = new Animation(scrollContent, [
                {offset: 0, transform: 'translateZ(0) translateY(0px)'},
                {offset: 1, transform: 'translateZ(0) translateY(-'+footerHeight+'px)'}
            ], footerDuration);
            return new ParGroup([
                footerAnimation,
                contentAnimation
            ]);
        }

        function fillBlock(block, pageIndex) {
            var ps = [], start = pageIndex*rowsPerPage, i=0;
            for (i=0; i<rowsPerPage; i++) {
                ps.push('<p>'+(start + i)+'</p>')
            }
            block.innerHTML = ps.join('');
        }

    </script>
    </body>
</html>

