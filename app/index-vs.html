<!doctype html>
    <head>
        <meta charset="utf-8">
        <title>touchanimation</title>
        <meta name="viewport" content="width=device-width">
        <!-- build:css(.tmp) styles/main.css -->
        <link rel="stylesheet" href="styles/main.css">
        <!-- endbuild -->
    </head>
    <body style="height: 400px">
    <div class="scroll-viewport" style="height: 200px; margin-top: 20px; border: 1px solid black; position: relative; overflow: hidden">
        <div class="scroll-indicator" style="position:absolute;right:0;top:0;z-index:1;width:4px;height:40px;background-color:red"></div>
        <div style="height: 100%; position:relative" class="inner-viewport">
            <div class="scroll-header" style="background-color:grey;height:40px;position:absolute;top:-40px;width:100%">
                <div style="text-align: center" class="pull-to-refresh">Pull to refresh</div>
            </div>
            <div class="scroll-footer" style="background-color:grey;height:40px;position:absolute;top:100%;width:100%;z-index:1">
                Bottom...
            </div>
            <div class="block0" style="border: 1px solid yellow;">Block0</div>
            <div class="block1" style="border: 1px solid blue;">Block1</div>
        </div>
    </div>
        <!--
        <p>
        Performance comparison: Native slider
        <input type="range" min="0" max="100" style="width:200px">
        </p>
        -->

        <!-- build:js scripts/vendor.js -->
        <!-- bower:js -->
        <script src="scripts/web-animations.js"></script>
        <!-- endbower -->
        <!-- endbuild -->

    <!-- build:js scripts/touch-animation.js -->
    <script src="scripts/utils.js"></script>
    <script src="scripts/gesture.js"></script>
    <script src="scripts/scroll-animation.js"></script>
    <!-- endbuild -->

    <script>
        var     rowCount = 40,
                rowsPerPage = 6;


        var scrollViewport = document.querySelector('.scroll-viewport'),
                innerViewport = document.querySelector('.inner-viewport'),
                scrollHeader = scrollViewport.querySelector('.scroll-header'),
                scrollFooter = scrollViewport.querySelector('.scroll-footer'),
                pullToRefresh = scrollHeader.querySelector('.pull-to-refresh'),
                indicator = scrollViewport.querySelector('.scroll-indicator'),
                block0 = scrollViewport.querySelector('.block0'),
                block1 = scrollViewport.querySelector('.block1');

        fillBlock(block0, 0);
        fillBlock(block1, 1);

        var     rowHeight = utils.getHeight(block0) / rowsPerPage,
                viewPortHeight = utils.getHeight(scrollViewport),
                headerHeight = utils.getHeight(scrollHeader),
                footerHeight = utils.getHeight(scrollFooter),
                pullToRefreshWidth = utils.getWidth(scrollHeader),
                indicatorHeight = utils.getHeight(indicator);

        var headerFooterSlowDownFactor = 5,
            headerDuration = headerHeight / viewPortHeight * headerFooterSlowDownFactor,
            footerDuration = footerHeight / viewPortHeight * headerFooterSlowDownFactor,
            contentDuration = (rowHeight * rowCount - viewPortHeight) / viewPortHeight;

        // document.timeline.play(totalAnimation());
        new ScrollAnimation({
            animation: totalAnimation(),
            timeToPixelRatio: viewPortHeight,
            gesture: new gesture.SlideYGesture(document.body, -1),
            headerDuration: headerDuration,
            footerDuration: footerDuration
        });

        function totalAnimation() {
            return new ParGroup([new SeqGroup([headerAnimation(), contentAnimation(), footerAnimation()]), indicatorAnimation()]);
        }

        function indicatorAnimation() {
            var start = new Animation(indicator, [
                {offset: 0, transform: 'translateZ(0) translateY(-'+(indicatorHeight*0.9)+'px)'},
                {offset: 1, transform: 'translateZ(0) translateY(0)'}
            ], headerDuration);
            var middle = new Animation(indicator, [
                {offset: 0, transform: 'translateZ(0) translateY(0px)'},
                {offset: 1, transform: 'translateZ(0) translateY('+(viewPortHeight-indicatorHeight)+'px)'}
            ], contentDuration);
            var end = new Animation(indicator, [
                {offset: 0, transform: 'translateZ(0) translateY('+(viewPortHeight-indicatorHeight)+'px)'},
                {offset: 1, transform: 'translateZ(0) translateY('+(viewPortHeight-indicatorHeight + indicatorHeight*0.9)+'px)'}
            ], footerDuration);
            return new SeqGroup([start, middle, end]);
        }

        function headerAnimation() {
            var headerAnimation = new Animation(innerViewport, [
                {offset: 0, transform: 'translateZ(0) translateY('+headerHeight+'px)'},
                {offset: 1, transform: 'translateZ(0) translateY(0px)'}
            ], headerDuration);
            var pullToRefreshAnimation = new Animation(pullToRefresh, [
                {offset: 0, transform: 'translateZ(0) rotate(0p)'},
                {offset: 1, transform: 'translateZ(0) rotate(360deg)'}
            ], headerDuration);
            return new ParGroup([headerAnimation, pullToRefreshAnimation]);
        }

        function footerAnimation() {
            var footerAnimation = new Animation(innerViewport, [
                {offset: 0, transform: 'translateZ(0) translateY(0px)'},
                {offset: 1, transform: 'translateZ(0) translateY(-'+footerHeight+'px)'}
            ], {
                duration: footerDuration
            });
            return footerAnimation;
        }
        function contentAnimation() {
            var blockHeight = rowHeight * rowsPerPage,
                blockDuration = 2*blockHeight / viewPortHeight,
                // TODO Bug: Setting this to Infinity and adding a oniteration event listener
                // stops the animation here!
                blockIterations = 100;
            var block0Anim = new Animation(block0, [
                { offset: 0, transform: 'translateZ(0) translateY(100%)' },
                { offset: 1, transform: 'translateZ(0) translateY(-100%)' }
            ], {
                iterationStart: 0.5,
                duration: blockDuration,
                iterations: blockIterations
            });

            var block1Anim = new Animation(block1, [
                { offset: 0, transform: 'translateZ(0) translateY(0%)' },
                { offset: 1, transform: 'translateZ(0) translateY(-200%)' }
            ], {
                duration: blockDuration,
                iterations: blockIterations
            });

            // TODO Bugs: with the events (why we are using a CustomEffect
            // and not onstart/onend/oniterate):
            // - no events while scrubbing backwards
            // - no events during running velocity animation. This might be due to the fact that
            //   we reparent the animation temporarily during animation.
            // - events in a seqgroup don't wait for the previous animations to fire

            var eventsAnim = new Animation(null, {
                sample: sampleEvents
            }, {
                duration: blockDuration,
                iterations: blockIterations
            });

            var block0Fill = 0,
                block1Fill = 1;
            function sampleEvents(time, iteration) {
                var block0FillNew,
                    block1FillNew;
                if (time >= 0.5) {
                    block0FillNew = (iteration+1)*2;
                } else if (time < 0.5) {
                    block0FillNew = iteration*2;
                }
                block1FillNew = iteration * 2 + 1;
                if (block0FillNew!=block0Fill) {
                    block0Fill = block0FillNew;
                    fillBlock(block0, block0Fill);
                }
                if (block1FillNew!=block1Fill) {
                    block1Fill = block1FillNew;
                    fillBlock(block1, block1FillNew);
                }
            }

            return new ParGroup([block0Anim, block1Anim, eventsAnim], {
                duration: contentDuration
            });
        }

        function fillBlock(block, pageIndex) {
            // console.log('filling block with page '+pageIndex);
            var ps = [], start = pageIndex*rowsPerPage, i=0;
            for (i=0; i<rowsPerPage; i++) {
                ps.push('<p>'+(start + i)+'</p>')
            }
            block.innerHTML = ps.join('');
        }

    </script>
    </body>
</html>

